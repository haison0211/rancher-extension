{"version":3,"file":"rancher-pod-metrics-1.0.0.umd.min.120.js","mappings":"gRAMM,SAAUA,EAASC,GACvB,IAAKA,GAAsB,kBAARA,EAAkB,OAAO,EAE5C,MAAMC,EAAUD,EAAIE,OACpB,IAAKD,EAAS,OAAO,EAErB,GAAIA,EAAQE,SAAS,KAAM,CAEzB,MAAMC,EAAQC,WAAWJ,EAAQK,MAAM,GAAI,IAC3C,OAAOC,MAAMH,GAAS,EAAIA,EAAQ,GACpC,CAAO,GAAIH,EAAQE,SAAS,KAAM,CAEhC,MAAMC,EAAQC,WAAWJ,EAAQK,MAAM,GAAI,IAC3C,OAAOC,MAAMH,GAAS,EAAIA,CAC5B,CAAO,CAEL,MAAMA,EAAQC,WAAWJ,GACzB,OAAOM,MAAMH,GAAS,EAAY,IAARA,CAC5B,CACF,CAMM,SAAUI,EAAYC,GAC1B,IAAKA,GAA4B,kBAAXA,EAAqB,OAAO,EAElD,MAAMR,EAAUQ,EAAOP,OACvB,IAAKD,EAAS,OAAO,EAErB,MAAMS,EAAmC,CACvC,GAAM,EAAI,KACV,GAAM,EACN,GAAM,KACN,GAAM,QACN,EAAK,EAAI,KAAO,MAChB,EAAK,EAAI,MACT,EAAK,IACL,EAAK,QAGP,IAAK,MAAOC,EAAMC,KAAeC,OAAOC,QAAQJ,GAC9C,GAAIT,EAAQE,SAASQ,GAAO,CAC1B,MAAMP,EAAQC,WAAWJ,EAAQK,MAAM,GAAIK,EAAKI,SAChD,OAAOR,MAAMH,GAAS,EAAIA,EAAQQ,CACpC,CAIF,MAAMR,EAAQC,WAAWJ,GACzB,OAAOM,MAAMH,GAAS,EAAIA,EAAQ,OACpC,CAMM,SAAUY,EAAUC,GACxB,IAAKA,GAA6B,IAAfA,EAAkB,MAAO,YAE5C,MAAMC,EAAOD,EAAa,IAC1B,MAAO,GAAGC,EAAKC,QAAQ,SACzB,CAMM,SAAUC,EAAaC,GAC3B,OAAKA,EAEDA,GAAO,KACF,IAAIA,EAAM,MAAMF,QAAQ,SAE1B,GAAGE,EAAIF,QAAQ,SALL,OAMnB,CAKM,SAAUG,EAAgBC,GAC9B,IAAIC,EAAW,EACXC,EAAc,EAGlB,IAAKF,IAASA,EAAKG,aAAeC,MAAMC,QAAQL,EAAKG,YACnD,MAAO,CACL1B,IAAK,EACLS,OAAQ,EACRoB,WAAY,YACZC,cAAe,SAKnB,IAAK,MAAMC,KAAaR,EAAKG,WACvBK,GAAaA,EAAUC,QACzBR,GAAYzB,EAASgC,EAAUC,MAAMhC,KACrCyB,GAAejB,EAAYuB,EAAUC,MAAMvB,SAI/C,MAAO,CACLT,IAAKwB,EACLf,OAAQgB,EACRI,WAAYb,EAAUQ,GACtBM,cAAeV,EAAaK,GAEhC,CAKOQ,eAAeC,EACpBC,EACAC,EACAC,GAEA,MAAMC,EAAa,IAAIC,IAGvB,IAAKJ,IAAUC,EAEb,OADAI,EAAQC,MAAM,0CACPH,EAGT,IAEE,MAAMI,EAAU,iBAAiBN,gCAC3BO,EAAMN,EACR,GAAGK,gBAAsBL,SACzB,GAAGK,SAEDE,QAAiBT,EAAMU,IAAIF,GAC3BG,EAAOF,EAASE,KAGtB,GAAIA,GAAQA,EAAKC,OAASpB,MAAMC,QAAQkB,EAAKC,OAC3C,IAAK,MAAMxB,KAAQuB,EAAKC,MAEtB,GAAIxB,EAAKyB,UAAYzB,EAAKyB,SAASX,WAAad,EAAKyB,SAASC,KAAM,CAClE,MAAMC,EAAM,GAAG3B,EAAKyB,SAASX,aAAad,EAAKyB,SAASC,OACxDX,EAAWa,IAAID,EAAK5B,EAAgBC,GACtC,CAGN,CAAE,MAAOkB,GAEP,MAAMW,EAAeX,EAAMY,SAAW,gBACtCb,EAAQC,MAAM,+BAAgCW,EAChD,CAEA,OAAOd,CACT,C","sources":["webpack://rancher-pod-metrics-1.0.0/./utils/metrics.ts"],"sourcesContent":["import type { PodMetricsResponse, PodMetricsItem, ParsedMetrics } from '../types/pod-metrics';\n\n/**\n * Parse CPU value from Kubernetes format to millicores\n * Examples: \"123m\" -> 123, \"1234n\" -> 0.001234, \"2\" -> 2000\n */\nexport function parseCPU(cpu: string): number {\n  if (!cpu || typeof cpu !== 'string') return 0;\n  \n  const trimmed = cpu.trim();\n  if (!trimmed) return 0;\n  \n  if (trimmed.endsWith('n')) {\n    // nanocores to millicores\n    const value = parseFloat(trimmed.slice(0, -1));\n    return isNaN(value) ? 0 : value / 1000000;\n  } else if (trimmed.endsWith('m')) {\n    // millicores\n    const value = parseFloat(trimmed.slice(0, -1));\n    return isNaN(value) ? 0 : value;\n  } else {\n    // cores to millicores\n    const value = parseFloat(trimmed);\n    return isNaN(value) ? 0 : value * 1000;\n  }\n}\n\n/**\n * Parse Memory value from Kubernetes format to MiB\n * Examples: \"123Mi\" -> 123, \"456Ki\" -> 0.445, \"1Gi\" -> 1024\n */\nexport function parseMemory(memory: string): number {\n  if (!memory || typeof memory !== 'string') return 0;\n  \n  const trimmed = memory.trim();\n  if (!trimmed) return 0;\n  \n  const units: { [key: string]: number } = {\n    'Ki': 1 / 1024,      // KiB to MiB\n    'Mi': 1,             // MiB\n    'Gi': 1024,          // GiB to MiB\n    'Ti': 1024 * 1024,   // TiB to MiB\n    'K': 1 / 1024 / 1.024, // K to MiB\n    'M': 1 / 1.024,        // M to MiB\n    'G': 1024 / 1.024,     // G to MiB\n    'T': 1024 * 1024 / 1.024 // T to MiB\n  };\n  \n  for (const [unit, multiplier] of Object.entries(units)) {\n    if (trimmed.endsWith(unit)) {\n      const value = parseFloat(trimmed.slice(0, -unit.length));\n      return isNaN(value) ? 0 : value * multiplier;\n    }\n  }\n  \n  // Plain bytes to MiB\n  const value = parseFloat(trimmed);\n  return isNaN(value) ? 0 : value / (1024 * 1024);\n}\n\n/**\n * Format CPU millicores to vCPU display\n * Always use vCPU for consistency\n */\nexport function formatCPU(millicores: number): string {\n  if (!millicores || millicores === 0) return '0.00 vCPU';\n  \n  const vCPU = millicores / 1000;\n  return `${vCPU.toFixed(2)} vCPU`;\n}\n\n/**\n * Format Memory MiB to display\n * Examples: 256 -> \"256 MiB\", 1536 -> \"1.5 GiB\"\n */\nexport function formatMemory(mib: number): string {\n  if (!mib) return '0 MiB';\n  \n  if (mib >= 1024) {\n    return `${(mib / 1024).toFixed(2)} GiB`;\n  }\n  return `${mib.toFixed(0)} MiB`;\n}\n\n/**\n * Parse pod metrics item to aggregated metrics\n */\nexport function parsePodMetrics(item: PodMetricsItem): ParsedMetrics {\n  let totalCPU = 0;\n  let totalMemory = 0;\n  \n  // Validate input\n  if (!item || !item.containers || !Array.isArray(item.containers)) {\n    return {\n      cpu: 0,\n      memory: 0,\n      cpuDisplay: '0.00 vCPU',\n      memoryDisplay: '0 MiB'\n    };\n  }\n  \n  // Sum all container metrics\n  for (const container of item.containers) {\n    if (container && container.usage) {\n      totalCPU += parseCPU(container.usage.cpu);\n      totalMemory += parseMemory(container.usage.memory);\n    }\n  }\n  \n  return {\n    cpu: totalCPU,\n    memory: totalMemory,\n    cpuDisplay: formatCPU(totalCPU),\n    memoryDisplay: formatMemory(totalMemory)\n  };\n}\n\n/**\n * Fetch pod metrics from metrics.k8s.io API\n */\nexport async function fetchPodMetrics(\n  axios: any,\n  clusterId: string,\n  namespace?: string\n): Promise<Map<string, ParsedMetrics>> {\n  const metricsMap = new Map<string, ParsedMetrics>();\n  \n  // Validate inputs\n  if (!axios || !clusterId) {\n    console.error('Invalid parameters for fetchPodMetrics');\n    return metricsMap;\n  }\n  \n  try {\n    // Build API URL\n    const baseUrl = `/k8s/clusters/${clusterId}/apis/metrics.k8s.io/v1beta1`;\n    const url = namespace \n      ? `${baseUrl}/namespaces/${namespace}/pods`\n      : `${baseUrl}/pods`;\n    \n    const response = await axios.get(url);\n    const data = response.data as PodMetricsResponse;\n    \n    // Validate response structure\n    if (data && data.items && Array.isArray(data.items)) {\n      for (const item of data.items) {\n        // Validate item has required metadata\n        if (item.metadata && item.metadata.namespace && item.metadata.name) {\n          const key = `${item.metadata.namespace}/${item.metadata.name}`;\n          metricsMap.set(key, parsePodMetrics(item));\n        }\n      }\n    }\n  } catch (error: any) {\n    // Log error but don't throw - return empty map to allow UI to handle gracefully\n    const errorMessage = error.message || 'Unknown error';\n    console.error('Failed to fetch pod metrics:', errorMessage);\n  }\n  \n  return metricsMap;\n}\n"],"names":["parseCPU","cpu","trimmed","trim","endsWith","value","parseFloat","slice","isNaN","parseMemory","memory","units","unit","multiplier","Object","entries","length","formatCPU","millicores","vCPU","toFixed","formatMemory","mib","parsePodMetrics","item","totalCPU","totalMemory","containers","Array","isArray","cpuDisplay","memoryDisplay","container","usage","async","fetchPodMetrics","axios","clusterId","namespace","metricsMap","Map","console","error","baseUrl","url","response","get","data","items","metadata","name","key","set","errorMessage","message"],"ignoreList":[],"sourceRoot":""}